const _ = require('lodash');

module.exports = simpleParser;

simpleParser.unparse = simpleUnparser;

/**
 * @name simpleParser
 *
 * @param {string} expr
 * The expression to parse
 *
 * @param {language} language
 * The language definition to use to parse the expression.  Entities, start, and
 * end criteria may either be characters or arrays of characters.
 *
 * @returns {parsetree}
 * The parse tree
 *
 * @description
 * Parses a simple expresion as defined by the given language.
 *
 * Useful for creating simple, non-recursive domain specific languages.
 *
 * Specifically, this service creates a function which parses any Chomsky
 * type-3 grammar that satisfies the given language specification, returning
 * a parse tree.
 */
function simpleParser(expr, language) {
	let i = 0;
	const escapeChar = '\\';
	return getGroup({ name: 'result', start: null, end: null, subgroups: language });

	/*
	 * Parse until the end of the group is reached, and return the parse
	 * tree
	 */
	function getGroup(group) {
		const result = [];
		let token = '';
		let c, subgroup;
		/*
		 * Entity (self-closing, has no contents)
		 *
		 * If entity has multiple start/end characters, the start/end
		 * properties (which would be arrays) must be equal BY REFERENCE.
		 *
		 * Also, ANY end character will end the group, not necessarily the
		 * same char/index that opened the group.
		 */
		if (group.end === group.start && group.start !== null) {
			return null;
		}
		/*
		 * We could possibly speed this up by pre-compiling regular
		 * expressions for each possible subgroup list, which would allow the
		 * actual looping logic to be moved into the runtime, but the
		 * performance of this simple implementation is already so damn fast
		 * for the current use case (comprehension expression syntax parsers)
		 * that I can't really be bothered.  Maybe in future if we start
		 * parsing big expressions frequently via this service...  That
		 * would presumably involve a "language compiler" which generates
		 * a set of regular expressions for each subgroup combination once,
		 * rather than it being done for each invocation of the parser.
		 */
		const isEndChar = group.end instanceof Array ?
			function (c) { return _.contains(group.end, c); } :
			function (c) { return group.end === c; };
		let escaped = false;
		while (escaped || !isEndChar(c = getChar())) {
			/* Test if char marks start of a subgroup */
			if (!escaped && (subgroup = isSubgroup(c))) {
				endToken();
				result.push({ type: subgroup.name, value: getGroup(subgroup) });
			} else {
				token += c;
				escaped = !escaped && c === escapeChar;
			}
		}
		endToken();

		return result;

		/* Store the current token */
		function endToken() {
			if (token.length) {
				result.push({ type: 'text', value: token });
				token = '';
			}
		}

		/* Is the given character marking the start of a subgroup? */
		function isSubgroup(c) {
			return _.find(group.subgroups, function (group) {
					return group.start instanceof Array ?
						_(group.start).contains(c) :
						group.start === c;
				});
		}
	}

	/* Read the next char of the expression */
	function getChar() {
		if (i > expr.length) {
			throw new Error('Unexpected end of expression');
		} if (i === expr.length) {
			i++;
			return null;
		} else {
			return expr.charAt(i++);
		}
	}
}

/**
 * @name simpleUnparser
 *
 * @param {parsetree} tree
 * The parse tree
 *
 * @param {language} language
 * The language to unparse to.
 *
 * @returns {string}
 * Expression which is invariant in a parse->unparse round-trip with the
 * given language.
 *
 * @description
 * This was used for testing the parser.
 *
 * Converts a parse tree generated by the {@link simpleParser}
 * back to a string.
 *
 * If two languages have the same structure, but different syntax, then
 * an expression can be parsed in one language, then unparsed into the
 * other language as a simple way to translate between them.
 */
function simpleUnparser(tree, language) {
	return unparseNodes(tree, language);

	function unparseNodes(nodes, phrases) {
		return _.map(nodes, function (node) {
			return unparseNode(node, phrases);
		}).join('');
	}

	function unparseNode(node, phrases) {
		if (node.type === 'text') {
			return node.value;
		} else {
			const block = _.findWhere(phrases, { name: node.type });
			if (block.start === block.end) {
				return ch(block.start);
			} else {
				if (!block) {
					throw new Error('Unknown phrase type: ' + node.type);
				}
				return ch(block.start) +
					unparseNodes(node.value, block.subgroups) +
					ch(block.end);
			}
		}

		function ch(arr) {
			return arr instanceof Array ? arr[0] : arr;
		}
	}

}
